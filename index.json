[{"categories":["算法 \u0026 数据结构"],"content":"详述了动态规划的概念，思路，及例题","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"动态规划 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"动态规划 动态规划 跟 “分治、递归、回溯”没有太大的区别，我们来看看动态规划的具体定义 simplifying a complicated problem by breaking it down into simpler sub-problems 这个是 wiki百科 对动态规划的解释，同时我感觉这是最好的解释 动态规划，个人觉得翻译成 “动态递推/动态推导” 是最好的，动态规划其实有点不直白 然后上述英文的意思则是 “把一个复杂的问题分解为更简单的子问题” 其实就是分治的思想，但是分治和动态规划只有小小的不一样，那就是第二点 动态规划 = 分治 + 最优子结构 一般来说 动态规划 会让你求 最优解 最大值 最小值，这也就是动态规划的应用场景 正因为，他有所谓的最优子结构，所以，你就不需要，将中间所有的状态都保存下来，只需要存最优的状态 重点总结 动态规划和 递归 分治 没有根本上的区别（关键是看有无最优子结构） 他们之间的共性就是 找到重复子问题 他们之间的差别就在于 动态规划有最优子结构，中途可以淘汰最优解 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"斐波那契数列 斐波那契额数列 我们都知道是可以用递归去解决，但是面试的时候，千万不能说用递归，傻递归的效率是极慢的 时间复杂度为指数级，也就是 O(2^n) 所以我们就得想办法来优化啦，我们可以加一个缓存，这个缓存可以用数组，这种叫做 “记忆化搜索” func fib(n int, memo []int) { // resursion terminator(递归终止条件) if (n \u003c= 1) { return 0 } if (memo[n] == 0) { memo[n] = fib(n - 1) + fib(n - 2) } return memo[n] } 在上述代码中我们通过增加数组实现的缓存，使得只要在数组出现的值就直接return，不让他参与遍历，把重复的节点直接砍掉，所以O(2^n) 变成了 O(n) 是不是贼棒，其实这个也是分治的思想，只不过加了个记忆化搜索 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"思想 - 自顶向下 我们在面对斐波那契时，当然可以用上述讲的 分治 + 记忆化搜索 来实现，其实这个思想就是 “自顶向下” 的思想 什么叫自顶向下呢？就是上述图片，我们一直从上面也就是fib(6)找到最下面的叶子结点 我要算 fib(6) 就得算fib(5) 和 fib(4) 我要算fib(5) 就得算fib(4) 和 fib(3) … 就如上述一直下去，中间算过的结果，我们可以用记忆化搜索，这种符合人脑的习惯，也是分治的思想 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:3:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"思想 - 自底向上 我们学习了自顶向下的方法，emmm，是不是感觉很不错，但是后来当我们遇到更难得dp也就是动态规划时，高手一般会直接用“自底向上”的思想 那么什么是自底向上呢 我们想算fib(6) 从fib(0) fib(1) 开始 然后一直用循环去递推 所以我们只需要了解自底向下思想即可，所以动态规划翻译成动态递推是不是很有道理 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:4:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"状态转移方程 状态转移方程也叫 dp方程 这个其实是要在例题1 例题2 后来讲的 这里为了工整性 提前说了 大家可以先看一下例题1 和例题2 的分析再来看 dp方程 和 关键点 思考步骤 两道例题 其实都有一个核心的关键方程 例题1 是 v[i] = v[i-1] + v[i-2] 例题2 是 v[i][j] = v[i-1][j] + v[i][j-1] 这类方程 我们叫状态转移方程 也叫dp方程 但是又回到 咬文嚼字上 这其实就是一个递推方程 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:5:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"dp 思考点 化繁为简，将复杂的问题 变成子问题，其实就是 找重复性（分治思想） 定义好状态空间 定义dp数组 \u0026\u0026 初始化dp数组 注意这里定义和初始化数组的长度一定要注意 有时候会是 “\u003e=” 或者其他的，如果定义错误，则会数组越界，或者答案错误 写好dp方程 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:6:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 爬楼梯 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:7:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"方法1 - 动态规划 URL 70. 爬楼梯 - 力扣（LeetCode） 代码示例 class Solution { public: int climbStairs(int n) { /* 定义dp数组 */ vector\u003cint\u003e dp(n+1); /* 初始化dp数组 */ dp[0] = 1; dp[1] = 1; /* dp方程 自底向上 */ for (int i = 2; i \u003c dp.size(); i++) { dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } }; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:7:1","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了位运算的一些场景","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"位运算 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:0:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"前言 本文分三个部分 有趣的位运算 算法比较常用的 n \u0026 (n - 1) 算法例题 位运算的基本概念 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"位运算符 左移 \u003c\u003c 0011 -\u003e 0110 右移 \u003e\u003e 0110 -\u003e 0011 按位或 | 0011 -----\u003e 1011 1011 按位与 \u0026 0011 -----\u003e 0011 1011 按位取反 ~ 0011 -\u003e 1100 按位异或 ^ 0011 -----\u003e 1000 1011 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"XOR 异或 异或: 相同为0 不同为1 也可用 \"不进位加法\" 来理解 异或操作的一些特点: x ^ 0 = x x ^ 1s = ~x // 注意 1s = ~0 x ^ (~x) = 1s x ^ x = 0 c = a ^ b =\u003e a ^ c = b, b ^ c = a // 交换两个数 a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative 有趣的位运算(一直更新补充) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将x最右边的n位清零 x \u0026 (~0 \u003c\u003c n) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"获取x的第n位值 (0 或者 1) (x \u003e\u003e n) \u0026 1 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:5:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"获取x的第n位的幂值 x \u0026 (1 \u003c\u003c (n - 1)) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:6:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"仅将第n位置为1 x | (1 \u003c\u003c n) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:7:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"仅见第n位置为0 x \u0026 (~(1 \u003c\u003c n)) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:8:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将x最高位至第n位 (含)清零 x \u0026 ((1 \u003c\u003c n) -1) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:9:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将第n位至第0位 x \u0026 (~((1 \u003c\u003c (n-1))-1)) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:10:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"判断奇偶 x % 2 == 1 ---\u003e (x \u0026 1) == 1 x % 2 == 0 ---\u003e (x \u0026 1) == 0 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:11:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"x » 1 —\u003e x / 2 即 x = x/2; ---\u003e x = x \u003e\u003e 1; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:12:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"得到最低位的1 X \u0026 -X ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:13:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"X \u0026 ~X -\u003e 0 X \u0026 ~X -\u003e 0 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:14:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将英文字符串转为大小写 大写变小写、小写变大写 : 字符 ^= 32; 大写变小写、小写变小写 : 字符 |= 32; 小写变大写、大写变大写 : 字符 \u0026= -33; /* 以上操作能够产生奇特效果的原因在于 ASCII 编码 字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了 */ ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:15:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"判断两个数是否异号 int x = -1, y = 2; bool f = ((x ^ y) \u003c 0); // true int x = 3, y = 2; bool f = ((x ^ y) \u003c 0); // false ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:16:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"交换两个数 int a = 1, b = 2;a ^= b;b ^= a;a ^= b; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:17:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"加1 int n = 1;n = -~n; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:18:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"减1 int n = 2;n = ~-n; // 现在 n = 1 算法常用操作 n\u0026(n-1) 这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:19:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 二进制中的1的个数 LCR 133. 位 1 的个数 - 力扣（LeetCode） 思路详解： `就是让你返回 n 的二进制表示中有几个 1 因为 n \u0026 (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止 int hammingWeight(uint32_t n) { int res = 0; while (n != 0) { n = n \u0026 (n - 1); res++; } return res; } 题目推荐 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:20:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 插入 题目url 面试题 05.01. 插入 - 力扣（LeetCode） 解题思路 先将N的第i ~ j位全部置零； 在将M左移i位，使之对其上一步中N置零的位，直接相加即可。 示例代码 class Solution { public: int insertBits(int N, int M, int i, int j) { for (int k = i; k \u003c= j; ++ k) { //举例说明： (1 \u003c\u003c 3) 表示 00001000，取反后得 11110111 // N \u0026= (11110111) 表示将 N 的第3位置零了 N \u0026= ~(1 \u003c\u003c k); } return N + (M \u003c\u003c i); } }; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:21:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"例题2 - 翻转数位 题目url 面试题 05.03. 翻转数位 - 力扣（LeetCode） 方法1 - 位运算 /* 在遍历num每一位时，追踪当前1序列的长度和上一段1序列的长度； 当遇到比特位为0时，分两种情况讨论： 1、若下一个比特位为1，那么preLen = curLen； 2、若下一个比特位为0，那么preLen = 0，我们不能合并这两个1序列 */ class Solution { public: int reverseBits(int num) { if (~num == 0) return 32; //全是1的情况，若不特判会输出33 int curLen = 0, preLen = 0； int maxLen = 1; //最少也能翻转1位 for (int i = 0; i \u003c 32; ++ i) { if ((num \u0026 1) == 1) { curLen ++ ; } else { preLen = ((num \u0026 2) == 0) ? 0 : curLen; //判断下一比特位是否为0 curLen = 0; } maxLen = max(maxLen, preLen + curLen + 1); num \u003e\u003e= 1; } return maxLen; } }; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:22:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了二分查找的概念，思路，及例题","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的思想-减而治之 二分查找通过不断缩小区间的范围来查找目标元素，这种\"不断缩小区间\"就是减而治之的思想 减而治之听起来高大上，其实就是排除法，我们每一次查找就排除掉一些元素，每一次重复此操作，自然就找到了我们的目标元素 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的应用范围 在有序数组中寻找一个目标值，有序和数组是重点 在整数范围内寻找一个目标值，也就是不一定是有序数组，旋转数组和山脉数组都可以用到二分法 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的算法思路 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"在循环体中查找元素 简介 此思路很简单，就是直接在数组中查找到目标元素 时间复杂度 O(log N)，这里的N是指数组的长度 空间复杂度：由于二分查找算法在执行的过程中只使用到常数个临时变量，因此空间复杂度是 O(1)。 代码模板 int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003c target) { left = mid + 1; } if (nums[mid] \u003e target) { right = mid - 1; } } } ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:1","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"在循环体中排除目标元素一定不存在的区间 简介 这种思路就是一直排除元素不存在的区间，然后剩下来最后一个数 也就是left = right的数，因为这里的循环条件就是while (left \u003c right) {}，最后进行这个数的判断是不是我们的目标数 时间复杂度 O(log N)，这里的N是指数组的长度 空间复杂度：由于二分查找算法在执行的过程中只使用到常数个临时变量，因此空间复杂度是 O(1)。 代码模板 int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003c target) { left = mid + 1; } if (nums[mid] \u003e target) { right = mid - 1; } } } ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:2","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的重点 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"循环条件 循环条件是一个很重要的东西，我们到底需要用left \u003c= right 还是使用left \u003c right，其实这就是跟思路有关了 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:1","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"取中间数的代码 一般来说我们取中间数都是用(left + right) / 2这么使用如果两个数特别大的时候会造成溢出的，所以我们不能这么用 最好的我们是使用left + (right - left) / 2，这个计算方法很好的避免了溢出这个问题，故二分法要这么去写 其实还有一个利用位运算很帅的一个方法，int mid = (left + right) \u003e\u003e 1; 比如这个代码，大家做个了解即可这是因为整数右移 1 位和除以 2（向下取整）是等价的，这样写的原因是因为位运算比整除运算要快一点。但事实上，高级的编程语言，对于 / 2 和除以 2 的方幂的时候，在底层都会转化成为位运算，我们作为程序员在编码的时候没有必要这么做，就写我们这个逻辑本来要表达的意思即可，这种位运算的写法，在 C++ 代码里可能还需要注意优先级的问题 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:2","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"中间数的代码要不要向上取整 int mid = left + (right - left) / 2中/ 2表示的含义其实是向下取整，如果最后区间位于中间的有两位数，那么只能取到左边的数，那么上取整和下取整有没有啥区别呢，其实是有的，这种区别我们可以在具体的题目中去感悟，哪一个 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:3","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"案例一 - 二分查找 在循环体中查找元素 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c= right) { int mid = (left + right) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003c target) { left = mid + 1; } if (nums[mid] \u003e target) { right = mid - 1; } } return -1; } }; 在循环体中排除目标元素一定不存在区间 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c right) { int mid = (left + right) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { right = mid; } } if (nums[left] == target) { return left; } return -1; } }; ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:5:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"案例二 - 猜数字大小 在循环体中查找元素 class Solution { public: int guessNumber(int n) { int left = 1, right = n; while (left \u003c= right) { int mid = left + (right - left) / 2; if (0 == guess(mid)) { return mid; } if (-1 == guess(mid)) { right = mid - 1; } if (1 == guess(mid)) { left = mid + 1; } } return -1; } }; 在循环体中排除目标元素一定不存在区间 class Solution { public: int guessNumber(int n) { int left = 1, right = n; while (left \u003c right) { int mid = left + (right - left) / 2; if (1 == guess(mid)) { left = mid + 1; } else { right = mid; } } return left; } }; 课后习题 搜索插入位置 在排序数组中查找元素的第一个和最后一个位置 寻找旋转排序数组中的最小值 寻找旋转排序数组中的最小值 II 搜索旋转排序数组 搜索旋转排序数组 II 第一个错误的版本 山脉数组的峰顶索引 山脉数组中查找目标值 寻找两个正序数组的中位数 x 的平方根 寻找重复数 转变数组后最接近目标值的数组和 爱吃香蕉的珂珂 分割数组的最大值 在 D 天内送达包裹的能力 制作 m 束花所需的最少天数 小张刷题计划 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:6:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了双指针的概念及场景和例题","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"双指针 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:0:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"引言 对于数组和链表 来说 “双指针\"其实是一个常用的解法了 双指针也是有很多种类的 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"普通双指针 什么是双指针 双指针模式指使用两个一前一后的指针遍历数据结构，直到某个指针触发停止条件 使用双指针的好处 单指针原本需要平方的时间复杂度，用了双指针便可优化到线性时间复杂度 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"快慢指针 什么是快慢指针 两个速度不同的指针 比如 “fast指针” 跑两格 “slow指针” 跑一格 可以拿龟兔赛跑去想象，在一个圆形赛道，“兔子 -\u003e 快指针” 肯定会追上 “乌龟 -\u003e 慢指针”，龟兔赛跑也经常用在判断链表是否成环上面 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:3:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"左右指针 来讲一讲题外话 其实 快慢指针 也有被说成 左右指针，但是本人认为这么说，其实是相当不合理，在此之上，我便有了一丝 朱光潜老先生的 “咬文嚼字” 的感觉，我始终认为 你给一个方法取名 其实就是代表了 你对这个方法的理解 比如了解什么是左右指针后 你把它叫做 “对撞指针” 也可以 这就是 “1000个读者有1000个哈姆雷特” 所以我也很推荐你们能拥有自己的想法 不要在意别人的命名 就好比 leetcode 题解 就有把快慢指针说为左右指针，你能说他错吗 其实快慢指针 也确实就是一个指针左 一个指针右 什么是左右指针 其实就是一个left指针从最左边向右跑，一个right指针从最右边向左跑 左右指针的代码模板 int left = 0, right = vector.size()-1; while (left \u003c= right) { ... } left, right := 0, len(array)-1 for left \u003c= right { ... } ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:4:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"滑动窗口 什么是滑动窗口 滑动窗口是一种基于双指针的一种思想，两个指针指向的元素之间形成一个窗口 其实可以把它当成一个队列 如果 窗口要向后滑动 直接把开头去掉即可~ 这只是其中一个实现思想 滑动窗口的应用场景 滑动窗口可解决一系列字符串匹配问题 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:5:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"双指针的应用场景 涉及 数组或链表，成对元素的集合、甚至是子数组 匹配一个「目标」值或是去除重复 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"趣谈 - KMP 另起了一个专题 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:7:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 数组 - 移动零 - 快慢指针 题目url 283. 移动零 - 力扣（LeetCode） 其他例题 26. 删除有序数组中的重复项 - 力扣（LeetCode） 88. 合并两个有序数组 - 力扣（LeetCode） ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:8:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题2 - 数组 - 盛最多水的容器 - 左右指针 题目url 11. 盛最多水的容器 - 力扣（LeetCode） 解题思路 这道题是 “求最优解”, 其实求最优解是 “贪心算法” 和 “动态规划\"的场景, 但是这里也可以用双指针 其他例题 189. 轮转数组 - 力扣（LeetCode） ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:9:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题3 - 链表 - 成环链表 - 快慢指针 题目url 141. 环形链表 - 力扣（LeetCode） 解题思路 成环链表 用 “快慢指针” 真的人人皆知 所以也要留个心眼 学个其他的解法 面试的时候 也是个亮点哦 其他例题 142. 环形链表 II - 力扣（LeetCode） ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:10:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题4 - 链表 - 反转链表 - 双指针 题目url 206. 反转链表 - 力扣（LeetCode） 解题思路 这道题我们可以这么看 1 -\u003e 2 -\u003e null 然后变成 null \u003c- 2 \u003c- 1 在遍历链表时，将当前节点的 next 指针改为指向前一个节点，由于节点没有引用其前一个节点，因此必须事先存储其前一个节点，在更改引用之前，还需要存储后一个节点。最后返回新的头引用 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:11:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题5 - 字符串 - 无重复字符的最长字串 题目url 3. 无重复字符的最长子串 - 力扣（LeetCode） ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:12:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了时间\u0026空间复杂度的概念及计算","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"时间复杂度 \u0026 空间复杂度 时间复杂度 O(1) 常数复杂度 O(log n) 对数复杂度 O(n) 线性时间复杂度 O(nlogn) 线性对数时间复杂度 O(n ^ 2) 平方 O(n ^ 3) 立方 O(2 ^ n) 指数 O(n!) 阶乘 O(1) \u003c O(logn) \u003c O(n) \u003c O(nlogn) \u003c O(n ^ 2) \u003c O(n ^ 3) \u003c O(2 ^ n) \u003c O(n!) ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:0:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(1) n := 1000 fmt.Println(n) ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(logn) 时间复杂度 O(logn) —对数阶，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标 代码 for i := 1; i \u003c n; i = i * 2 { fmt.Println(i) } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n) for i := 0; i \u003c n; i++ { fmt.Println(i) } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n + m) for i := 0; i \u003c n; i++ { fmt.Println(i) } for j := 0; j \u003c m; j++ { } // O(n + m) ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:4:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(nlogn) 线性对数阶O(nlogn)其实非常容易理解，将对数阶O(logn)的代码循环n遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)，归并排序的复杂度就是O(nlogn) for (int m = 1; m \u003c= n; m++) { int i = 1; while (i \u003c n) { i = i * 2; } } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:5:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n ^ 2) for i := 0; i \u003c n; i++ { for j := 0; j \u003c n; j++ { fmt.Println(i) fmt.Println(j) } } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:6:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(nm) for i := 0; i \u003c n; i++ { for j := 0; j \u003c m; j++ { fmt.Println(i) fmt.Println(j) } } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:7:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(k ^ n) func fib(n int) int { if n \u003c= 0 { return 1 } return n * fib(n - 1) } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:8:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"时间复杂度减少 计算: 1 + 2+ 3 + 4 + 5 + .. + n 方法1: y = 0 for i = 1; i \u003c= n; i++ { y += i } 方法2 求和公式: y = n * (n+1)/2 ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:9:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"图示总结 空间复杂度 ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:10:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"leetcode 常争论的一个点 func test(n int) []int { res := make([]int, 0) res = append(res, n) return res } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:11:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(1) int i; ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:12:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n) int[] arr; ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:13:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n ^ 2) int[][] arr; ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:14:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"}]